1、 interpose是接收一个分隔符和一个序列，将序列插入到低序列的中间。
    interleave是接收两个序列，将序列相互交叉，长度以最短的序列长度为准。
    
2、 匿名函数也可以重载，如：
    (fn a 
    	([] (println "hi"))
	([x] (println x)))

3、 （1）reify创建一个匿名类。
     (str (let [f "foo"] 
        (reify Object 
     	    (toString [this] f))))

      == "foo"

    (seq (let [f "foo"] 
        (reify clojure.lang.Seqable 
          (seq [this] (seq f)))))
  
    == (\f \o \o))

  同时也可以使用proxy创建匿名类。proxy同reify的区别是前者可以添加新的函数，后者不能。
  （2）创建接口可以使用defprotocol，如
	(defprotocol IBark (bark [this]))
     使用reify创建调用
	(bark (reify IBark (bark [this] (println "bark"))))
  （3） reify、proxy创建的是匿名类，defrecord、deftype创建的是剧名类。
  （4） 使用extend-protocol函数可以对现有的类进行扩展，如
  	(extend-protocol IBark
	    java.util.Map
	    (bark [this]
	        (or (:bark this)
		    (get this "bark"))))
       直接将一个原有的java类扩展新的接口。
  (5)因为函数第一个参数是对象本身，类似与java里的this，故defprotocol函数定义的接口的第一个参数名记为this（只调用对象本身）。

4、 在lazy-seq函数中，使用cons为数组形式，如([1 2] [1 2 3] [1 2 3 4])；使用conj是嵌套形式，如(1 2 (1 2 3 (1 2 3 4 ())))。

5、 取map的value值，使用vals，取key值为keys。在使用map函数是也可使用#(nth % 2)取

6、 partition-by与group-by函数类似，只是group-by是对全局进行分组，partition-by是局部分组。如：
    (group-by #(rem % 3) [1 1 1 3 3 4 5 5 1 1])
    == {1 [1 1 1 4 1 1], 0 [3 3], 2 [5 5]}

   (partition-by #(rem % 3) [1 1 1 3 3 4 5 5 1 1])
   == ((1 1 1) (3 3) (4) (5 5) (1 1))

7、for 后面的方括号是一个vector，r是xml-seq返回的sequence，x是sequence中的元素，每次循环都自动获取下一个元素，:when(...)是条件判断语句。当when(...)返回true的时候就执行vector后面的表达式，因为这里仅仅是x,所以将这个符号条件的元素作为for的返回值。
    user=> (for [x r :when (= :mongodb (:tag x))] x)  
    ({:tag :mongodb, :attrs nil, :content [{:tag :uri, :attrs nil, :content ["localhost"]}]})  
    user=>   
 :when 不会阻止循环提前结束，但是:while就不同了。
 如果:while(...) 计算出结果为false，则循环立刻退出。
 所以下面返回空list
 user=> (for [x r :while (= :mongodb (:tag x))] x)  
 ()

8、some函数提供了类似R中any的功能（更强大）,all对应的是every?，此外还有not-any?等函数。

9、case中的选项可以使用括号括起来，指定同一个答案。如:
    #(case %
        1 true
	2 true
	3 true
	4 false
	5 false)
   可以写成:
   #(case % (1 2 3) true (4 5) false) 选项的列表之前不加'。

10、定义命名空间的ns宏，其中有一批指令： :exclude :only :as :refer-clojure :import :use :load :require。例子：
  (ns joy.ns-ex
    ;排查clojure.core里的defstruct
    (:refer-clojure :exclude [defstruct])
    ;没有命名空间限定的情况下使用set和xml
    (:use (clojure set xml))
    ;没有命名空间限定的情况下使用test的are和is，其他函数不导入
    (:use [clojure.test :only (are is)])
    ；加载命名空间，同时赋予别名z
    (:require (clojure [zip :as z]))
    ；导入java类Date和File，也可导入deftype和defrecord定义的类
    (:import (java.util Date)
    	     (java.io File)))

    注：一般情况下不用使用:use导入全部命名空间的数据，需要使用是要使用:only限定。否则影响效率。

11、对应clojure中的tree数据结构，使用clojure.zip里的函数进行操作。

12、	组合函数 comp。从后向前依次调用  
	偏态函数partial。 构建一个函数，第一个参数是函数名，其余的参数是函数的参数
	反函数complement。 构建一个函数的反函数

13、使用正则查找
	#加字符串构成一个正则化，类型是java.util.regex.Patten
	可以使用re-find函数查找，如(re-find #"Hi" "Hi,wo,Hi") => "Hi"
	re-matcher可以进行matcher匹配

12、关键字不属于任何命名空间，但可以对关键字进行限定。
	如：
	    :t => :t
	    ::t => :user/t
	全限定关键字的命名空间可以不存在，但在所限定的命名空间之外使用时，需要加上命名空间。
	全限定关键字使用是开始也是两个冒号::t或者:命名空间/关键字 :user/t。::t同:t不是一个关键字
	（详细讲解见《clojure编程乐趣》 p69 4.3.2全限定关键字

13、dorun 对产生副作用的函数，重复求值惰性序列，类似于take。
	(def infinity-hi (repeatedly #(println "hi")))
	(dorun 5 infinity-hi)

14、iterate 产生一个(f x) (f (f x)) (f (f (f x))) ……的惰性序列

15、使用gen-interface可以声明一个java接口。

16、函数的参数为java的数组类型是，可以使用#=(java.lang.Class/forName "[×")来声明。如对应java函数 void a(byte[] bs)，clojure的声明为 [a [#=(java.lang.Class/forName "[B")] void]

17、clojure使用gensym函数可以创建变量
    user=> (defmacro a [xs] (let [x (repeatedly 2 gensym )] `(for [~@(interleave x xs)] [~@x])))
    #'user/a
    user=> (macroexpand-1 '(a [[1 2] [3 4]]))
    (clojure.core/for [G__10646 [1 2] G__10647 [3 4]] [G__10646 G__10647])
    user=> (a [[1 2] [3 4]])
    ([1 3] [1 4] [2 3] [2 4])

18、配置clojure的开发选项，只在编译时有用
	:profiles {:provided {:dependencies [[..]]}}

19、定义函数，使用keyword。
	(1)直接定义
		(defn f [a {:keys [b c d] :or {b 1}}] b)
		调用的时候为: (f 1 {:b 1 :c 2 :d 3})
		注意：后边的{:b 1 :c 2 :d 3}不能省略，因为参数需要一样多
	(2)使用可变参数
		(defn f [a & {:keys [b c d] :or {b 1}}] a)
		调用的时候为： (f 1) 或者 (f 1 :b 1 :c 2 :d 3)
		后边的可以省略，且不需要写出map，因为&符会把后边的全部变成序列

20、clojure中通过import引入的类直接使用类名的话同java中类调.class函数相同，例如：
    (import 'java.lang.Math)
    Math
    同 Math.class相同

21、丢掉最后一个元素butlast和drop-last

22、将字符串转换为clojure变量，实现反序列化的过程可以使用read-string函数。
    user=> (+ 11 (read-string "9"))
    20
    user=> (read-string "(+ 1 2)")
    (+ 1 2)
    如果想要执行PersistenList，可以使用eval命令就可以执行.
    user=> (eval (read-string "(+ 1 2)"))
    3

23、对于clojure中的PersistenList,可以使用eval命令执行：
    user=> (eval '(+ 1 2)
    3
    user=> (eval (read-string "(+ 1 2)"))
    3

24、map中选择多个key，使用select-keys函数，用法(select-keys map keyseq)，结果为一个map。
    user=> (select-keys {:a 1 :b 2 :c 3 :d 4} [:a :b])
    {:a 1, :b 2}

25、对于要求结果的惰性函数，使用doall来求值，不要使用dorun，dorun的返回结果为nil
    user=> (dorun (pmap inc (range 4)))
    nil
    user=> (doall (pmap inc (range 4)))
    (1 2 3 4)

26、gen-class使用的几个问题：
    （1）如果返回的时数组，类型可以直接写成"[D"等类型;
    （2）导出函数需要在gen-class中使用:methods
    （3）导出的函数原型要比:methods中的函数多一项，即在总前面加指向本身的this
    例子：
	(ns test-gen.core
	  (:gen-class
	   :name testGen.TestGen
	   :methods [[testGen [] "[D"]]))
	
	(defn -testGen
	  [this]
	  (double-array [1 2 3 4]))

    如果参数类型为别别的数组，如Object[]、String[]，则类型我"[Ljava.lang.Object;"、"[Ljava.lang.String;"。methods后边为:methods [[testGen [] "[java.lang.Ojbect;"]]
